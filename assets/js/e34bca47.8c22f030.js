"use strict";(self.webpackChunkapi_docs_generator=self.webpackChunkapi_docs_generator||[]).push([[750],{6137:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>l,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"tech/web","title":"Web Integration","description":"Harbour provides a dev and a prod environment under the following URLs:","source":"@site/docs/tech/web.md","sourceDirName":"tech","slug":"/tech/web","permalink":"/docs/tech/web","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Web3 SDK","permalink":"/docs/tech/sdk"},"next":{"title":"Networks","permalink":"/docs/tech/networks"}}');var s=t(4848),r=t(8453);const o={},a="Web Integration",d={},c=[{value:"Using the nonprod environment",id:"using-the-nonprod-environment",level:2},{value:"Using the prod environment",id:"using-the-prod-environment",level:2},{value:"How it works",id:"how-it-works",level:2},{value:"Price quotes",id:"price-quotes",level:2},{value:"Redirect specification",id:"redirect-specification",level:2},{value:"Producing a valid signature",id:"producing-a-valid-signature",level:3},{value:"Ethereum",id:"ethereum",level:4}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"web-integration",children:"Web Integration"})}),"\n",(0,s.jsx)(n.p,{children:"Harbour provides a dev and a prod environment under the following URLs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Dev: ",(0,s.jsx)(n.code,{children:"https://dev-ramp.harborapps-nonprod.link"})]}),"\n",(0,s.jsxs)(n.li,{children:["Prod: ",(0,s.jsx)(n.code,{children:"https://ramp.harbour.fi"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"using-the-nonprod-environment",children:"Using the nonprod environment"}),"\n",(0,s.jsx)(n.p,{children:"The nonprod environment can be used during development, especially if developers wish to also take a look at how the\nfunctionality looks like for a registered customer. Once a dev user is redirected to our app, they can either witness\na fake sign up flow by providing a phone number, or they can sign in with the following credentials:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Country: ",(0,s.jsx)(n.code,{children:"Germany"})]}),"\n",(0,s.jsxs)(n.li,{children:["Phone Number: ",(0,s.jsx)(n.code,{children:"+49 777 7908 100"})]}),"\n",(0,s.jsxs)(n.li,{children:["Post code: ",(0,s.jsx)(n.code,{children:"90147"})]}),"\n",(0,s.jsx)(n.li,{children:"Date of Birth: Jan 1st 1989"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Once a crypto address is linked to this test user, any subsequent redirect will recognise the user and not require any\nfurther login. Testing the journey again with a different user will require using a separate crypto address."}),"\n",(0,s.jsx)(n.p,{children:"Supported tokens:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["USDC on Avalanche Fuji C-Chain Testnet (",(0,s.jsx)(n.code,{children:"0x5425890298aed601595a70AB815c96711a31Bc65"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["USDC on Ethereum Sepolia Testnet (",(0,s.jsx)(n.code,{children:"0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Note: buying and selling won't be possible, as our dev environment does not use real bank accounts, and thus it's not\npossible to pay with or receive real money. However, our testnet integration is fully functional, and you can reach out\nto our team if you wish to simulate a transaction."}),"\n",(0,s.jsx)(n.h2,{id:"using-the-prod-environment",children:"Using the prod environment"}),"\n",(0,s.jsx)(n.p,{children:"Using prod is exactly the same as dev, except for the fact that you can sign up for real, as long as you're a European\nresident and have a phone number in the country you sign up from. It can be used for software integration purposes,\nas the integration only requires implementing the redirect, and does not require signup up."}),"\n",(0,s.jsx)(n.p,{children:"As long as our web app does not display an error message, and offers to sign up the user, your dev team will know that\nthe integration works and all URL parameters have been validated."}),"\n",(0,s.jsx)(n.p,{children:"Supported tokens:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["USDC on Ethereum Mainnet (",(0,s.jsx)(n.code,{children:"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["USDC on Avalanche Mainnet C-Chain (",(0,s.jsx)(n.code,{children:"0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["USDC on Polygon Mainnet (",(0,s.jsx)(n.code,{children:"0x3c499c542cef5e3811e1192ce70d8cc03d5c3359"}),")"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,s.jsx)(n.p,{children:"The integrating app can choose whether it simply redirects the user to our web app, or also collects some initial\ninformation, such as whether the user wishes to buy or sell, which token, and which amount. Our app is made of three\nsteps: choose the token, choose an amount and get an estimated quote, and then proceed to the payment. When buying, the\nlast step displays the bank payment instructions; when selling, the last step displays the crypto payment instructions\nand potentially a wallet integration to sign the transaction from a desktop browser."}),"\n",(0,s.jsx)(n.p,{children:"Should the app choose to collect that information from the user beforehand, it has the option of passing it in\nHarbour's URL parameters, making it possible to skip the first step and show a price quote directly to the user."}),"\n",(0,s.jsx)(n.p,{children:"The integrating app can also improve user experience by providing a digital signature, to prove ownership of the crypto\naddress by the customer. Providing this signature beforehand will allow us to skip the part where a user has to connect\ntheir wallet and sign a payload from their browser wallet plugin. It also allows using Harbour from a mobile device,\nsince browser extensions won't be necessary."}),"\n",(0,s.jsx)(n.h2,{id:"price-quotes",children:"Price quotes"}),"\n",(0,s.jsx)(n.p,{children:"If the integrating app wishes to provide a price quote to the user, typically when comparing Harbour with other ramp\nproviders, they'll have to integrate with our RPC API."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"TODO add API docs"})}),"\n",(0,s.jsx)(n.p,{children:"Harbour pricing works by calculating a fair mid-price of the asset being exchanged, across multiple exchanges of our\nchoice. A service fee is deducted from the fiat portion, and the network fee (only when buying crypto) is deducted\nfrom the crypto portion."}),"\n",(0,s.jsx)(n.h2,{id:"redirect-specification",children:"Redirect specification"}),"\n",(0,s.jsx)(n.p,{children:"Except for the price quote, no further API integration is necessary and the only required step is to redirect the user\nto our web app. Note that:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Initially we'll only support redirects"}),"\n",(0,s.jsx)(n.li,{children:"We plan on supporting iframes in the future, by optimizing our UI for any screen size"}),"\n",(0,s.jsx)(n.li,{children:"In our first beta iteration, we require a signature to demonstrate ownership if the address used for ramping. In\nfuture iterations the signature will be optional and the user will have to connect their wallet on the Harbour web app\nand will be asked to sign a payload."}),"\n"]}),"\n",(0,s.jsxs)("table",{children:[(0,s.jsx)("th",{children:"Query Param"}),(0,s.jsx)("th",{children:"Optional"}),(0,s.jsx)("th",{children:"Allowed Values"}),(0,s.jsx)("th",{children:"Description"}),(0,s.jsxs)("tbody",{children:[(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"asset"}),(0,s.jsx)("td",{children:"yes"}),(0,s.jsx)("td",{children:"ETH_USDC | POLY_USDC | AVAX_USDC"}),(0,s.jsx)("td",{children:"Optional token to buy or sell. If missing or empty, Harbour's UI will ask the user what they intend to use."})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"op"}),(0,s.jsx)("td",{children:"yes"}),(0,s.jsx)("td",{children:"buy | sell"}),(0,s.jsx)("td",{children:"Optional operation specifier. If missing, Harbour's UI will ask the user whether they want to buy or sell."})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"amount"}),(0,s.jsx)("td",{children:"yes"}),(0,s.jsx)("td",{children:"any numeric"}),(0,s.jsx)("td",{children:(0,s.jsx)(n.p,{children:"Optional amount specifier. If missing, Harbour's UI will ask the user the amount the want to ramp.\nDepending on the maximum precision of the token and the minimum increments we support, we might truncate\nthe tail of the decimal part."})})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"sig"}),(0,s.jsx)("td",{children:"no"}),(0,s.jsx)("td",{children:"any string"}),(0,s.jsx)("td",{children:(0,s.jsx)(n.p,{children:'Mandatory url-encoded signature to demonstrate ownership of a cryptographic public key.\nCheck the "Producing a valid signature" section below for more details.'})})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"hash"}),(0,s.jsx)("td",{children:"yes"}),(0,s.jsx)("td",{children:"any string"}),(0,s.jsx)("td",{children:(0,s.jsx)(n.p,{children:'For ethereum signatures produced via personal_sign instead of eth_sign, this parameter should be set to "ethereum".\nMore details are provided in the docs for producing the signature. For any other use case, it should be omitted.'})})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"pubkey"}),(0,s.jsx)("td",{children:"no"}),(0,s.jsx)("td",{children:"any string"}),(0,s.jsx)("td",{children:"Mandatory url-encoded public key of the crypto address the user wants to ramp to/from."})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"address"}),(0,s.jsx)("td",{children:"no"}),(0,s.jsx)("td",{children:"any string"}),(0,s.jsx)("td",{children:"Mandatory blockchain address the user wants to ramp from/to."})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"ts"}),(0,s.jsx)("td",{children:"no"}),(0,s.jsx)("td",{children:"integer"}),(0,s.jsx)("td",{children:"Mandatory timestamp used when producing the signature (unix milliseconds)."})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"origin"}),(0,s.jsx)("td",{children:"yes"}),(0,s.jsx)("td",{children:"any string"}),(0,s.jsx)("td",{children:(0,s.jsx)(n.p,{children:"Optional unique identifier for the originating app. Get in touch with our team to know your ID and get Harbour's UI\nto adhere to your color scheme and earn Harbour points on every user that interacts with our service."})})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"producing-a-valid-signature",children:"Producing a valid signature"}),"\n",(0,s.jsx)(n.h4,{id:"ethereum",children:"Ethereum"}),"\n",(0,s.jsxs)(n.p,{children:["Following are the instructions to produce a valid signature given an Ethereum address and public key.\nCheck the ",(0,s.jsx)(n.a,{href:"#redirect-specification",children:"redirect specification"})," for a list of all URL parameters that can be passed."]}),"\n",(0,s.jsxs)(n.p,{children:["Let's analyze ",(0,s.jsx)(n.code,{children:"address"})," and ",(0,s.jsx)(n.code,{children:"pubkey"}),". The address has to be passed in the format expected by the Ethereum protocol,\nsuch as ",(0,s.jsx)(n.code,{children:"0x123..."}),". The pubkey can be passed in either base64/urlencoded or hex encoded strings.\nIf you wish to use hex encoding, ensure you prefix the address with 0x so that our code recognises it as a hex string,\nelse it will default to try parsing it as base64."]}),"\n",(0,s.jsx)(n.p,{children:"The address has to be the address on which the user wants to get their funds when buying, or from which they intend to\nsend the funds when selling. The pubkey has to be the key from which the address is derived. You can pass either the\ncompressed or uncompressed public key."}),"\n",(0,s.jsxs)(n.p,{children:["The last parameter is ",(0,s.jsx)(n.code,{children:"sig"}),", which is the signature of a Harbour custom payload, produced by using the private key\ncorresponding to the public key discussed above. Again, it can either be in base64/urlencoded or hex encoded."]}),"\n",(0,s.jsx)(n.p,{children:"The payload is built as such:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"take the address bytes"}),"\n",(0,s.jsx)(n.li,{children:"get the current timestamp as unix epoch milliseconds"}),"\n",(0,s.jsx)(n.li,{children:"convert the timestamp to a string"}),"\n",(0,s.jsx)(n.li,{children:"get the Unicode bytes of such string"}),"\n",(0,s.jsx)(n.li,{children:"append the timestamp bytes to the address bytes"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The payload should then be signed, and you have two options to do so:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Manually take care of hashing with keccak256 and then signing with the private key (raw signing)."}),"\n",(0,s.jsxs)(n.li,{children:["Using a library which implements personal message signing. This is an algorithm that adds a special prefix\n",(0,s.jsx)(n.code,{children:'"\\x19Ethereum Signed Message:\\n"'})," to the payload, and then hashes the result with keccak256 and finally signs it."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Should you go with the message signing instead of raw signing, you need to add the ",(0,s.jsx)(n.code,{children:"hash=ethereum"})," query parameter to\nour redirect URL."]}),"\n",(0,s.jsx)(n.p,{children:"See the following examples on how to create a valid signature with ethers.js:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/harbour-tech/harbour-ts-sdk/blob/main/src/examples/example-eth-new-api.ts",children:"raw signing example"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/harbour-tech/harbour-ts-sdk/blob/main/src/examples/example-eth-new-api-personalsign.ts",children:"personal message signing example"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If you try running the script, you should get a bunch of console logs and a valid access token from our dev backend.\nNote that you don't need to do this API integration yourself, it's just a convenient way to showcase exactly how you\ncan build a valid signature."}),"\n",(0,s.jsx)(n.p,{children:"To put your implementation to the test, you can set up a test case with the following inputs:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["private key: ",(0,s.jsx)(n.code,{children:"0x4ffa17bae4e3eb082aecc21145c6e40b16f10f7e950a4ccfdcc176c9199d42fd"})]}),"\n",(0,s.jsxs)(n.li,{children:["corresponding pub key uncompressed: ",(0,s.jsx)(n.code,{children:"0xe32a36ecddcf5269a998a9c6d27ccb56ba59f0cc9ae5961e5747304fc06ad090"})]}),"\n",(0,s.jsxs)(n.li,{children:["timestamp: ",(0,s.jsx)(n.code,{children:"1724162236365"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Note that the private key corresponds to our example file. With the above inputs, if you choose to adopt raw signing,\nyour function should determine the following:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["the hex-encoded payload (pubkey + timestamp) is\n",(0,s.jsx)(n.code,{children:"0x04792b75fc27f4f3f9cd33ef5130fdd8286c3416836728e1f783c41bf52a2bd5ab54ad58e7f64cd6716dde3054d6063b8493ee8275d60cbba31444a97f8fc5afca31373234313632323336333635"})]}),"\n",(0,s.jsxs)(n.li,{children:["keccak hash of the payload is ",(0,s.jsx)(n.code,{children:"0xe32a36ecddcf5269a998a9c6d27ccb56ba59f0cc9ae5961e5747304fc06ad090"})]}),"\n",(0,s.jsxs)(n.li,{children:["signature is expected to be\n",(0,s.jsx)(n.code,{children:"0xb619c9699b6f98e0bac45d02bca3d5b854fc6e23f8b7c10f02f91ed41bf8f9df1e606392b4f54422da7a3c4992bc984b7aafcd3fd9ed57369f271f9278f96cd91b"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Alternatively, should you choose to adopt personal message signing, you can set up a test case with the exact same\nkeypair and timestamp, and expect the signature to be:\n",(0,s.jsx)(n.code,{children:"0x0d779dda1ca405ff07181d9c8a2743503c6479641e7c076dd379e39837a839626b80fedb71edf60597c484928b76c38672d6b229aac4de4750ef0df2eebf911e1b"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"If your signing function passes the above spec, it is guaranteed to function with our backend, given the following\nrequirements:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"the timestamp must be within 1 minute of the current time"}),"\n",(0,s.jsx)(n.li,{children:"a valid Ethereum key must be used, according to secp256k1"}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);